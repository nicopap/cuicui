# Systems as `Modify`

- `impl_modify` is a real weird macro
- `Modify` relies extensively on `impl_modify` for dependency detection
- `Modify` is not extensible: Users can't add their own modifiers (unless using `dyn TextModifier`)

Individual `Modify` could be "systems"; Rather, functions with a special
argument called `Path![Component; .field]`. `Path` would have following properties:

- Things it reads from
- Things it writes to
- Component accessed (to convert to `WorldQuery` so that it can be queried)

There is a few challenges yet:

1. How do bindings work?
2. How to build the static modifier list?
3. How to build the field list?
4. How to operate on a list within a component?
5. How to compile time error on attempt to access mutably same field?

(5) we would need to panic at runtime.

(2) Could have a builder method on `App`, that has `.add_modifier(modifer)`
and `.finish()` to "commit" the final set of modifiers

**Problem:** This would prevent extensiblility right? Maybe we can provide
`add_modifier_list` and export modifier lists? (**solved**)

(1): bindings work by mutating a `Modify`. If `Modify` are systems, they can't
be mutated.

The `Modify` systems could accept an additional "local state" parameter.
Store the local state outside of the system, and pass it to the system when
it runs.

**Problem:** The enum generated by `impl_modify` has the advantage of locality,
since it's just an enum. When `Resolver::update` we iterate over a list of them.

This might be costly, if the state is stored in a list of erased values
(like a `Box<[Box<dyn Any>]>`), bunch of pointer chasing, and memory fragmentation.

Note that we could also store them in the ECS. But how? Not as `Resource` since
we want multiple instances of the same type runnng.

Probably in a way similar to how I did it with `bvyfst_hollow_scene`, an heterogenous list.
It would accumulate the type as new builder methods are invocked, and erase it on `.finish()`.
--> This doesn't work because we need to store state per _modifier instance in the format string_
rather than one per system modifier.
--> I wonder if it's possible to create heterogenous lists with `bevy_ptr`?
--> Maybe create an internal `World` and store the states in `Component`s.
    Each instance of a `Modify` would have its own entity.
    we could require users to derive a `ModifyState`, which itself would derive `Component`
(**unsolved**)

(3) currently relies on generating an `enum` with all the possible fields.
I guess I could replace the `EnumMultimap<M::Field, ModifyIndex, MOD_COUNT>`
by something more reasonable. (**solved**)

(4) If the `Modify::Items` individual `Item` has greater section accuracy than
individual entities, we can't operate in `Item` within a `Vec` within a `Component`.
This would throw out of the window `RichText` and potentially many unknown future use-cases.

Could it be possible to make `Path!` accept a special syntax to "splice" an inner
`Vec` into multiple items?

- Like in `jq`, we could do `Path![Text; .sections[].style]`
to 
- But then we'd have to handle multiple-level access like: 

```rust
fn print_alignment(align: Path![Text; .alignment], content: Path![Text; .sections[].value]) {
  // ...
}
```

Worse! What about a component with two distinct `Vec` fields? This needs design.
(**unknown**)